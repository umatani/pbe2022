<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>5. 高階手続きによる抽象 再訪</title>
    <link rel="stylesheet" href="../tufte.css"/>
    <link rel="stylesheet" href="../latex.css"/>
    <link rel="stylesheet" href="../umatani.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 綺麗なアイコン -->
    <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"
          rel="stylesheet"/>
    <!-- <\!-- Highlight.js -\-> -->
    <!-- <link rel="stylesheet" href="highlight/styles/default.css"/> -->
    <!-- <script src="highlight/highlight.pack.js"></script> -->
    <!-- <script>hljs.initHighlightingOnLoad();</script> -->
    <!-- 数式 -->
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ['\\(','\\)'] ]
          }
      });
    </script>
  </head>

  <body>
    <nav class="top">
      <ul>
        <li>&nbsp;</li>
        <li>
        <a href="../chap/04_hof.html">&larr; Previous</a>

        </li>
        <li><a href="../index.html"><i class="fas fa-home"></i> Home</a></li>
        <li><a href="../chap/06_absdata.html">Next &rarr;</i></a></li>
      </ul>
    </nav>
    <article>
      <h1 id="tufte-css"><div id="top"/>
        5. 高階手続きによる抽象 再訪

      </h1>


      <ul class="signpost"><li>　</li><li><a href="../pdf/jsicp.pdf#page=88" class="external">テキスト： 1.3節</a></li><li><a href="../src/ex/ex05.zip" class="internal">配布ファイル： ex05.zip</a></li></ul>
      <section><h2>はじめに</h2><p>前回に引き続き1.3節の高階手続きの演習を行います．今回は1.3.4節の問題です．</p></section><section><h2>トピックス</h2><p>これまでは，Emacs の各種機能のうち，どんなプログラミング言語でコードを書く場合であっても有用な機能を中心に紹介してきました．今回は，Scheme（Lisp）言語（より正確には括弧を多用する言語）を効率良く編集する操作について紹介します．これを覚えると，Scheme コードの編集作業が非常に捗りますので，ぜひマスターして以降の演習で活用してください．</p><h3>式単位の編集</h3><p>これまでのトピックスで出てきた Emacs の様々な操作では，1文字や1行を編集対象の単位として扱っています．たとえば，C-f はカーソルを1文字分だけ前方に動かす操作ですし，C-k は1行分<label for="side17492" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17492" class="margin-toggle"/><span class="sidenote">正確にはカーソルの現在位置から行の末尾まで．</span>を切り取る操作です．</p><p>こう書くと，「そんなの当たり前じゃないか，それ以外にどんな方法があるんだ」という声が聞こえてきそうです．しかし，一般的なプログラミング言語のコードでは，その一部分を区切る単位として，文字や行のようなバッファ（ファイル）中の表面的な配置とは別に，それらと直接関係のない論理的単位を用いることが可能です<label for="side17493" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17493" class="margin-toggle"/><span class="sidenote">自然言語の文法にも「単語」「文節」等々，論理的な単位があります．</span>．Scheme 言語のコードにおける論理的単位は，これまでずっと扱ってきている<strong>式（expression）</strong>です．</p><p>これまで見てきたとおり，Scheme（Lisp）の式は，括弧によってその構造が明確であることが大き特徴です．これは，C 言語 や Java 言語で書かれたコードとは対照的です．たとえば，</p><div class="highlight"><pre><code>(+ (* 1 2)
   (/ (- 3 4)
      5))</code></pre></div><p>という Scheme の算術式を，これらの言語では<label for="side17494" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17494" class="margin-toggle"/><span class="sidenote">Scheme の例に合わせて改行を入れているので，若干不自然です．</span>：</p><div class="highlight"><pre><code>1 * 2
+ (3 - 4)
  / 5</code></pre></div><p>のように，優先順位を変えるために必要な箇所以外に括弧をつけることを強制はしません．また，関数定義が論理的単位であるにも関わらず，関数定義全体を：</p><div class="highlight"><pre><code>{
  int main() {
    printf("Hello, world.\n");
  }
}</code></pre></div><p>のように括弧で括ったりもしません．</p><p>一方，Scheme を含め Lisp 系言語ではあらゆる論理的単位を必ず括弧で括ります．そのせいで，「括弧が多すぎて Lisp で書かれたプログラムは読みにくい」と揶揄されることがありますし，それを否定も出来ません．しかし，Emacs のような Lisp フレンドリーなエディタでは，必ず括弧がついていることを最大限に活用することで，Lisp コードの論理的単位での編集作業をぐっと簡単にしています．</p><p>Scheme コードの編集作業において，行単位で編集することによる生じる問題点の一例を，簡単なコードを使って説明します．次の手続き定義を編集中だとします．</p><div class="highlight"><pre><code>(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))</code></pre></div><p>仮に本体式の <code>(* n (factorial (- n 1)))</code> を削除したいとしましょう<label for="side17495" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17495" class="margin-toggle"/><span class="sidenote">間違ってないのでその必要はないのですが...</span>．ここで4行目に対し，C-k を使ってこの行全体の削除を行うと，</p><div class="highlight"><pre><code>(define (factorial n)
  (if (= n 0)
      1</code></pre></div><p>となり，本体中にある部分式だけを消したかったのに，<code>if</code> 式の終わりを表す閉じ括弧と <code>define</code> 式の終わりを表す閉じ括弧まで一緒に消してしまうことになります．</p><p>「1行消した後で閉じ括弧を2つ足せばいいじゃないか」と思うかも知れません．この例のような簡単な場合であればそのとおりです．しかし，もっと複雑なコードを編集するような場合には，「今，余分に〇個の括弧を消した」とか「後からここに〇個の括弧を足さないと対応がつかない」のような面倒くさい事を，コードを編集している人間の頭の中でいちいち数え，そして記憶しておく必要があります．もしかしたら，編集作業の最中に LINE やメールが届いて中断し，再開した時にはすっかり忘れてしまっているということも十分にあり得ます．</p><p>このような問題は，<strong>編集中のコードをそもそも括弧の対応がつかないようなアンバランスな状態にはしない</strong>よう常に気を配りながら編集すれば避けることができます<label for="side17496" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17496" class="margin-toggle"/><span class="sidenote">Emacs には閉じ括弧を入力したり，開き括弧の直前・閉じ括弧の直後にカーソルを持っていくと対応する括弧が強調表示されるといった機能があり，これから紹介する編集操作を知らなくても，括弧の対応を保つのは比較的楽です．それでも，この例のように誤って括弧の対応を完全に無視した編集作業を行うことは十分にあり得ます．</span>．そのような編集方法の一つに，<a href="02_proc.html#region" class="internal">前々回に紹介した領域選択</a>があります．C-SPC と C-w を組み合わせることで，次のように必要な範囲だけを削除できます．</p><figure class=""><label for="fig17497" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig17497" class="margin-toggle"/><a href="../fig/05/c-w.gif"><img src="../fig/05/c-w.gif" alt=""/></a><span class="marginnote"></span></figure><p>しかし，このように自分でどの閉じ括弧までかを確認しながら領域を選択するのは面倒ですし，間違いのもとです<label for="side17498" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17498" class="margin-toggle"/><span class="sidenote">最後の閉じ括弧のあたりでモタついてるのが分かるでしょうか&#128517;</span>．</p><p>以上，前置きが長くなりましたが，文字単位や行単位の編集の不便さが少しは伝わったのではないかと思います．それでは，その不便さを解消する便利な式単位の編集操作について順に見ていきましょう．</p><p>まず，これまでに出てきた文字単位や行単位での編集操作（の一部）の一覧です．</p><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-f</code></td><td>カーソルを右（forward）へ1文字分だけ移動</td></tr><tr><td><code>C-b</code></td><td>カーソルを左（backward）へ1文字分だけ移動</td></tr><tr><td><code>C-n</code></td><td>カーソルを下（next）へ1行分だけ移動</td></tr><tr><td><code>C-p</code></td><td>カーソルを上（previous）へ1行分だけ移動</td></tr><tr><td><code>C-a</code></td><td>カーソルを現在行の先頭へ移動</td></tr><tr><td><code>C-e</code></td><td>カーソルを現在行の末尾へ移動</td></tr><tr><td><code>C-SPC</code></td><td>カーソル位置にマークを設定</td></tr><tr><td><code>C-k</code></td><td>行末尾までの切り取り</td></tr></table><p>これらのキーバインディングに対し，さらに「M-」（Meta キーの同時押し）を追加<label for="side17499" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17499" class="margin-toggle"/><span class="sidenote">つまり，C-M-&lt;key&gt; はCtrl キーと Meta キーと &lt;key&gt; キーの3つを同時に押すことになります．</span>すると，それぞれ式単位の編集へと変わります．それぞれの操作が式単位になった場合の，正確な意味は以下のとおりです．なお，<strong>トップレベル式</strong>とは，一番外側にある（つまり，別の手続き定義や変数定義の内部に書かれているのではない）式のことです．</p><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-M-f</code></td><td>カーソルを右（forward）へ<strong>式1つ分</strong>だけ移動</td></tr><tr><td><code>C-M-b</code></td><td>カーソルを左（backward）へ<strong>式1つ分</strong>だけ移動</td></tr><tr><td><code>C-M-a</code></td><td>カーソルを現在の<strong>トップレベル式</strong>の先頭へ移動</td></tr><tr><td><code>C-M-e</code></td><td>カーソルを現在の<strong>トップレベル式</strong>の末尾へ移動</td></tr><tr><td><code>C-M-k</code></td><td>カーソル位置の<strong>直後の式全体</strong>を切り取り</td></tr><tr><td><code>C-M-SPC</code></td><td>カーソル位置の<strong>直後の式全体</strong>を領域選択</td></tr></table><p>簡単な Scheme コードで実際に試してみればすぐに理解できると思いますが，操作例の動画を以下に載せておきます．</p><ul><li><p>strong{C-M-f，C-M-b}</p><figure class="fullwidth"><label for="fig17500" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig17500" class="margin-toggle"/><a href="../fig/05/c-m-f.gif"><img src="../fig/05/c-m-f.gif" alt=""/></a><span class="marginnote"></span></figure><p>C-M-f と C-M-b で式単位で行ったり来たりできます．動画の前半では外側のリストの2つの要素の間を，後半では内側のリストの4つの要素の間を行ったり来たりしています．</p><p>カーソルの直後に部分式の始まり（開き括弧）がある位置にだけジャンプしていることに注意してください．常にそのような場所にカーソルを置いておけるため，次の C-M-k や C-M-SPC と組み合わせると便利です．</p></li><li><p><strong>C-M-k</strong></p><figure class="fullwidth"><label for="fig17501" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig17501" class="margin-toggle"/><a href="../fig/05/c-m-k.gif"><img src="../fig/05/c-m-k.gif" alt=""/></a><span class="marginnote"></span></figure><p>見てのとおり，対応する閉じ括弧を自分で探さなくても済みます．なお，切り取った文字列を貼り付けるのは通常の C-y です．</p></li><li><p><strong>C-M-SPC</strong></p><p>C-M-SPC を連続して複数回押すことで，直後の式，その次の式，さらにその次の式，．．．と選択範囲を広げていくことが可能です．</p><figure class="fullwidth"><label for="fig17502" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig17502" class="margin-toggle"/><a href="../fig/05/c-m-w.gif"><img src="../fig/05/c-m-w.gif" alt=""/></a><span class="marginnote"></span></figure><p>この動画だと，C-M-SPC を3回連続で押すことで <code>if</code> 式の3つの部分式を選択し，次に C-w を押すことでまとめて切り取っています．当然ながら，C-M-SPC を1回押してから C-w を押すのと，C-M-k は同じ意味になります．</p></li></ul><p>上記の表に加えて，コードの自動インデントにも式単位バージョンがあります．racket モードでは，TAB キーを押すと行単位で正しい位置になるようインデントを自動で追加してくれますが<label for="side17503" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17503" class="margin-toggle"/><span class="sidenote">これまでちゃんと説明してなかったかも...まあ気づいてましたよね．</span>，これについても，C-M-q を押すと直後の式全体を自動インデントしてくれます．関数定義を一発できちんとインデントしてくれたりするので，地味な機能ですがすごく便利です．</p><p>また，Emacs の編集操作ではありませんが，Racket 言語にはコメントにも式単位の書き方が用意されています．テキストで説明されているとおり，Scheme 言語ではコード中に「<code>;</code>」を書くと，そこから行末までがコメントアウトされます．Racket ではそれに加えて，コード中に「<code>#;</code>」を書くと，直後の式全体がコメントアウトされます．Emacs ではコメントアウトされた範囲の文字色が変わるので，試してみればどういうことかすぐに分かると思います．</p><p>Racket にはまた，C言語の「<code>/* ... */</code>」のような複数行コメントに対応する「<code>#| ... |#</code>」という書き方も用意されています<label for="side17504" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side17504" class="margin-toggle"/><span class="sidenote">が，「<code>#;</code>」ほど便利ではないので私はあまり使いません．</span>．</p></section><p><anchor id="exercise"></anchor></p><section><h2>今週の課題</h2><p>今回は，</p><blockquote><p><strong>解いた課題の★の数の合計が3個以上</strong></p></blockquote><p>であることを最低条件とします．もちろん，それに縛られず一つでも多くの課題にチャレンジしてください．</p><ul><li>解いた課題の★の数の合計：3個以上</li><li>提出期限：5/18(水) 19:00</li><li>zip に圧縮するディレクトリ名：<tt>ex05</tt></li><li>提出する zip ファイル名：<tt>ex05.zip</tt></li></ul><div class="exercise"><h4>課題5.1 [★] [<a href="../pdf/jsicp.pdf#page=110" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.40を解きなさい．配布ファイル <code>ex05/ex05-1.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(cubic a b c)</code> を定義しなさい．</p></p></div><div class="exercise"><h4>課題5.2 [★] [<a href="../pdf/jsicp.pdf#page=110" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.41を解きなさい．配布ファイル <code>ex05/ex05-2.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(double f)</code> を定義しなさい．</p></p></div><div class="exercise"><h4>課題5.3 [★] [<a href="../pdf/jsicp.pdf#page=110" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.42を解きなさい．配布ファイル <code>ex05/ex05-3.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(compose f g)</code> を定義しなさい．</p></p></div><div class="exercise"><h4>課題5.4 [★★] [<a href="../pdf/jsicp.pdf#page=111" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.43を解きなさい．配布ファイル <code>ex05/ex05-4.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(repeated f n)</code> を定義しなさい．</p><p>このファイル先頭の <code>(require "ex05-3.rkt")</code> と，ファイル <code>ex05-3.rkt</code> 中の <code>(provide compose)</code> によって，<code>ex05-3.rkt</code> 中に定義されている <code>(compose f g)</code> をこのファイルから呼び出すことができる．</p></p></div><div class="exercise"><h4>課題5.5 [★★★] [<a href="../pdf/jsicp.pdf#page=111" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.44を解きなさい．配布ファイル <code>ex05/ex05-5.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(smooth f)</code> を定義しなさい．微小な値 <code>dx</code> には，必ず以下の定義を用いること．</p><div class="highlight"><pre><code>(define dx 0.00001)</code></pre></div><p>さらに，<code>smooth</code> と課題5.4 (テキスト問題1.43)の <code>repeated</code> を使い，n重平滑化関数 <code>(n-fold-smooth f n)</code> を定義しなさい．</p><p>このファイル先頭の <code>(require "ex05-4.rkt")</code> と，ファイル <code>ex05-4.rkt</code> 中の<code>(provide repeated)</code> によって，<code>ex05-4.rkt</code> 中に定義されている<code>(repeated f n)</code> をこのファイルから呼び出すことができる．</p></p></div><div class="exercise"><h4>課題5.6 [★★★] [<a href="../pdf/jsicp.pdf#page=111" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.45を解きなさい．配布ファイル <code>ex05/ex05-6.rkt</code> に解答コードを書き加えて完成させること．</p><p>問題文の説明に従って <code>x</code> の <code>n</code> 乗根を求める手続き <code>(nth-root n x)</code> を定義しなさい．</p><p>このファイル先頭の <code>(require "ex05-4.rkt")</code> と，ファイル <code>ex05-4.rkt</code> 中の <code>(provide repeated)</code> によって，<code>ex05-4.rkt</code> 中に定義されている <code>(repeated f n)</code> をこのファイルから呼び出すことができる．</p></p></div><div class="exercise"><h4>課題5.7 [★★★] [<a href="../pdf/jsicp.pdf#page=112" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.46を解きなさい．配布ファイル <code>ex05/ex05-7.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(iterative-improve good-enough? improve)</code> を定義しなさい．さらに，<code>iterative-improve</code> を使って，<a href="../pdf/jsicp.pdf#page=51" class="external">1.1.7節</a>の <code>(sqrt x)</code> と<a href="../pdf/jsicp.pdf#page=99" class="external">1.3.3節</a>の <code>(fixed-point f first-guess)</code> を定義しなさい．<code>fixed-point</code> が使用する <code>tolerance</code> には，テキストと同じ下の定義を必ず用いること．</p></p></div></section><p><anchor id="literacy-table"></anchor></p><section><h2>リテラシ関連項目まとめ</h2><p>利便性のため，前回までの操作方法・コマンドも全て含んでいます．今回追加された項目は<strong>太字</strong>で表しています．</p><h3>Emacs</h3><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-f</code></td><td>カーソルを右（forward）へ1文字分だけ移動</td></tr><tr><td><code>C-b</code></td><td>カーソルを左（backward）へ1文字分だけ移動</td></tr><tr><td><code>C-n</code></td><td>カーソルを下（next）へ1行分だけ移動</td></tr><tr><td><code>C-p</code></td><td>カーソルを上（previous）へ1行分だけ移動</td></tr><tr><td><code>C-v</code></td><td>カーソルを下へ1画面分だけ移動</td></tr><tr><td><code>M-v</code></td><td>カーソルを上へ1画面分だけ移動</td></tr><tr><td><code>M-&lt;</code></td><td>カーソルをバッファの先頭へ移動</td></tr><tr><td><code>M-&gt;</code></td><td>カーソルをバッファの末尾へ移動</td></tr><tr><td><code>C-a</code></td><td>カーソルを現在行の先頭へ移動</td></tr><tr><td><code>C-e</code></td><td>カーソルを現在行の末尾へ移動</td></tr><tr><td><code>C-x C-g</code></td><td>カーソルを指定行へ移動</td></tr><tr><td><code>C-l</code></td><td>カーソルのある行が画面の中央になるよう再描画</td></tr><tr><td><code>C-d</code></td><td>カーソル上の1文字を削除</td></tr><tr><td><code>C-h</code></td><td>カーソル直前の1文字を削除</td></tr><tr><td><code>C-SPC</code></td><td>カーソル位置にマークを設定</td></tr><tr><td><code>C-w</code></td><td>選択範囲を切り取り</td></tr><tr><td><code>M-w</code></td><td>選択範囲をコピー</td></tr><tr><td><code>C-y</code></td><td>キルリングの内容を貼り付け</td></tr><tr><td><code>C-k</code></td><td>行末尾までの切り取り</td></tr><tr><td><code>C-x C-f</code></td><td>ファイルを開く</td></tr><tr><td><code>C-x C-s</code></td><td>ファイルの保存</td></tr><tr><td><code>C-x C-c</code></td><td>Emacs を終了</td></tr><tr><td><code>C-x b</code></td><td>表示するバッファを変更</td></tr><tr><td><code>C-x C-b</code></td><td>バッファ管理用バッファを表示</td></tr><tr><td><code>C-x k</code></td><td>バッファを閉じる</td></tr><tr><td><code>C-g</code></td><td>コマンドの中断</td></tr><tr><td><code>C-x 2</code></td><td>ウィンドウを上下に分割</td></tr><tr><td><code>C-x 5</code></td><td>ウィンドウを左右に分割</td></tr><tr><td><code>C-x 1</code></td><td>ウィンドウを1つにする</td></tr><tr><td><code>C-x o</code></td><td>アクティブなウィンドウの切り替え</td></tr><tr><td><code>C-s</code></td><td>前向きにインクリメンタル検索</td></tr><tr><td><code>C-r</code></td><td>後ろ向きにインクリメンタル検索</td></tr><tr><td><code>M-%</code></td><td>文字列の置換</td></tr><tr><td><code>M-x eshell</code></td><td>シェルを起動</td></tr></table><h3>Racketモード</h3><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-c C-k</code></td><td>ソースファイルを対話環境に読み込む</td></tr><tr><td><code>C-c C-z</code></td><td>ソースファイルと対話環境の間のカーソル移動</td></tr><tr><td><strong><code>C-M-f</code></strong></td><td><strong>カーソルを右（forward）へ式1つ分だけ移動</strong></td></tr><tr><td><strong><code>C-M-b</code></strong></td><td><strong>カーソルを左（backward）へ式1つ分だけ移動</strong></td></tr><tr><td><strong><code>C-M-a</code></strong></td><td><strong>カーソルを現在のトップレベル式の先頭へ移動</strong></td></tr><tr><td><strong><code>C-M-e</code></strong></td><td><strong>カーソルを現在のトップレベル式の末尾へ移動</strong></td></tr><tr><td><strong><code>C-M-k</code></strong></td><td><strong>カーソル位置の直後の式全体を切り取り</strong></td></tr><tr><td><strong><code>C-M-SPC</code></strong></td><td><strong>カーソル位置の直後の式全体を領域選択</strong></td></tr><tr><td><strong><code>C-M-q</code></strong></td><td><strong>カーソル位置の直後の式全体を自動インデント</strong></td></tr></table><h3>シェル</h3><table><tr><th width="180px">コマンド</th><th>意味</th></tr><tr><td><code>pwd</code></td><td>カレントディレクトリを表示（present working directory）</td></tr><tr><td><code>cd </code><i>dir</i></td><td>カレントディレクトリを <i>dir</i> へ変更．<i>dir</i> を指定しない場合はホームディレクトリへ変更（change directory）</td></tr><tr><td><code>ls </code><i>dir</i></td><td>ディレクトリ <i>dir</i> の中身（<i>dir</i> を省略した場合はカレントディレクトリの中身）をリスト表示（list）</td></tr><tr><td><code>cp </code><i>src</i><code> </code><i>dst</i></td><td>ファイル <i>src</i> を <i>dst</i> へコピー（copy）</td></tr><tr><td><code>cp -r </code><i>src</i><code> </code><i>dst</i></td><td>ディレクトリ <i>src</i> 全体を <i>dst</i> へコピー（copy）</td></tr><tr><td><code>mv </code><i>src</i><code> </code><i>dst</i></td><td>ファイル <i>src</i> を <i>dst</i> へ移動（move）</td></tr><tr><td><code>rm </code><i>file</i> ...</td><td><i>file</i> ... を削除（remove）</td></tr><tr><td><code>rm -r </code><i>dir</i></td><td>ディレクトリ <i>dir</i> 全体を削除（remove）</td></tr><tr><td><code>echo </code><i>msg</i></td><td>文字列 <i>msg</i> を標準出力に表示</td></tr><tr><td><code>mkdir </code><i>dir</i></td><td>ディレクトリ <i>dir</i> を作成（make directory）</td></tr><tr><td><code>unzip </code><i>file</i></td><td>zip ファイル <i>file</i> をカレントディレクトリに展開</td></tr><tr><td><code>zip -r </code><i>file</i><code> </code><i>dir</i></td><td>ディレクトリ <i>dir</i> を zip ファイル <i>file</i> に圧縮</td></tr><tr><td><code>diff </code><i>old</i><code> </code><i>new</i></td><td>ファイル <i>old</i> と ファイル <i>new</i> を比較</td></tr><tr><td><code>grep </code><i>str</i><code> </code><i>file</i> ...</td><td>文字列 <i>str</i> を ファイル <i>file</i> ... の中から検索</td></tr><tr><td><code>find </code><i>dir</i><code> -name '</code><i>file</i><code>'</code></td><td>名前が <i>file</i> にマッチするファイルをディレクトリ <i>dir</i> から探す</td></tr></table></section>
    </article>
    <nav class="bottom">
      <ul>
        <li>&nbsp;</li>
        <li>
        <a href="../chap/04_hof.html">&larr; Previous</a>

        </li>
        <li><a href="../index.html"><i class="fas fa-home"></i> Home</a></li>
        <li><a href="../chap/06_absdata.html">Next &rarr;</i></a></li>
        <li class="right copy">&copy; 2022 Seiji Umatani</li>
      </ul>
    </nav>
  </body>
</html>