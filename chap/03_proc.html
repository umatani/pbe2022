<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8"/>
    <title>3. 手続きと手続きが生む過程</title>
    <link rel="stylesheet" href="../tufte.css"/>
    <link rel="stylesheet" href="../latex.css"/>
    <link rel="stylesheet" href="../umatani.css"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 綺麗なアイコン -->
    <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css"
          rel="stylesheet"/>
    <!-- <\!-- Highlight.js -\-> -->
    <!-- <link rel="stylesheet" href="highlight/styles/default.css"/> -->
    <!-- <script src="highlight/highlight.pack.js"></script> -->
    <!-- <script>hljs.initHighlightingOnLoad();</script> -->
    <!-- 数式 -->
    <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ['\\(','\\)'] ]
          }
      });
    </script>
  </head>

  <body>
    <nav class="top">
      <ul>
        <li>&nbsp;</li>
        <li>
        <a href="../chap/02_basic.html">&larr; Previous</a>

        </li>
        <li><a href="../index.html"><i class="fas fa-home"></i> Home</a></li>
        <li><a href="../chap/04_hof.html">Next &rarr;</i></a></li>
      </ul>
    </nav>
    <article>
      <h1 id="tufte-css"><div id="top"/>
        3. 手続きと手続きが生む過程

      </h1>


      <ul class="signpost"><li>　</li><li><a href="../pdf/jsicp.pdf#page=61" class="external">テキスト： 1.2節</a></li><li><a href="../src/ex/ex03.zip" class="internal">配布ファイル： ex03.zip</a></li></ul>
      <section><h2>はじめに</h2><p>今週の内容は以下のとおりです．</p><ul><li>トピックス</li><li>今週の課題</li></ul><p>トピックスでは，不定期で Emacs や Racket の便利な使い方を，少しずつ紹介していきます．</p></section><section><h2>トピックス</h2><p>前回に引き続き，今回も Emacs，Racket モード，シェルの便利機能をいくつか紹介します．ここで紹介している使い方を知っているのと知らないのとでは，プログラミングにおける作業効率が大きく変わってきます．本演習では，この先たくさんのプログラムを書いていかないといけませんから，少しでも作業効率を上げるため，是非使いこなせるようになってください．</p><p>誇張ではなく，これらを知らなければ数時間を要するような課題が，数十分で終わることもあります．すぐには全部を覚えられないかも知れませんが，少しずつでも身につけていきましょう．「急がば回れ」の精神で，道具を上手に使いこなせるようになることが結局は近道です<label for="side11828" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11828" class="margin-toggle"/><span class="sidenote">プログラミングに限らず，料理であれ楽器の演奏であれ，技術の習得は何でもそうです．</span>．なにより，段々と使いこなせるようになる自分を実感できると，プログラミングそのものが楽しく感じられてくるはずです．</p><p>これらの道具の使い方に関する質問も歓迎します．「Emacs の中で○○みたいなことがしたいんですが，どうすれば実行できますか？」のように，遠慮なく質問を投げてください．他のみんなにとっても有用なことなら，次回以降のトピックスでとりあげていこうと思います．</p><h3>Emacs におけるカーソル移動操作</h3><p>前回は，カーソル移動の方法として C-f，C-b，C-n，C-p の4つを覚えました．しかし，これらは上下左右に1文字分ずつしか移動できないため，サイズの大きなファイルの中をあちこち移動するのには，あまり向いていません．そこで，もう少し「遠く」まで移動するためのコマンドをいくつか紹介しておきます．</p><ul><li><p><strong>C-v，M-v</strong></p><p>C-v を押すとカーソルが下向きに1画面分だけ移動します．反対に，M-v を押すとカーソルが上向きに1画面分だけ移動します．ここで，M-&lt;<i>key</i>&gt; という表記は，前回説明した Meta キー<label for="side11829" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11829" class="margin-toggle"/><span class="sidenote">Windows では左 Alt キー</span>と &lt;<i>key</i>&gt; キーを同時に押すことを意味します．</p></li><li><p><strong>M-&lt;，M-&gt;</strong></p><p>M-&lt; を押すとカーソルが開いているファイルの先頭に移動します．反対に，M-&gt; を押すとカーソルが開いているファイルの末尾に移動します<label for="side11830" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11830" class="margin-toggle"/><span class="sidenote">&lt; が左向きの矢印，&gt; が右向きの矢印を意味し，ファイルの中身が左から右に列んでいるとイメージすると覚えやすいと思います．</span>．</p><p>なお，<code>&lt;</code> や <code>&gt;</code> はシフトキーを 押して入力する必要がありますが，この場合，Metaキーとシフトキーを同時に押します．</p></li><li><p><strong>C-a，C-e</strong></p><p>C-a を押すとカーソルが現在の行の先頭（つまり左端）に移動します．反対に，C-e を押すとカーソルが現在の行の末尾（つまり右端）に移動します．</p><p>C-a はこの後説明する行単位のコピーペースト作業を行う際，頻繁に使用します．</p></li><li><p><strong>C-x C-g</strong><label for="side11831" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11831" class="margin-toggle"/><span class="sidenote">標準の Emacs キーバインディングとは少し異なり，<code>init.el</code> の中で設定してあります．<code>init.el</code> については<a href="#init-el" class="internal">後述</a>します．</span></p><p>特定の行番号を指定して，直接そこへ移動します．対話環境中のエラー表示からソースファイルの該当する行番号が分かっている場合などに便利です．</p></li></ul><p>これらの移動操作自体は直感的に分かりやすいので，試してみればすぐに要領を掴めると思います．ただ，カーソル移動によってファイル中を行ったり来たりしていると，ファイルの中身の見たい範囲が画面にちょうど収まらず，不満を感じることがあると思います．そういう場合には，C-l キーを押してみてください．現在カーソルのある行がウィンドウのちょうど中央にくるよう再描画されます<label for="side11832" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11832" class="margin-toggle"/><span class="sidenote">C-l キーを連続して押すと，カーソルの位置が「中央」「一番上」「一番下」となるよう再描画され続けます．ですが，現在行を中央に調整するだけで済むことがほとんどだと思います．</span>．</p><h3>ウィンドウとバッファ</h3><p>今回の課題を前から順に解いていくことを考えてみます．まずは，Emacs で <code>ex03-1.rkt</code> を開きましょう<label for="side11833" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11833" class="margin-toggle"/><span class="sidenote">キーバインディングは C-x C-f でした．</span>．</p><figure class=""><label for="fig11834" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11834" class="margin-toggle"/><a href="../fig/03/ex03-1.png"><img src="../fig/03/ex03-1.png" alt=""/></a><span class="marginnote"></span></figure><p>前回はきちんと説明していませんでしたが，Emacs画面中の各部にはそれぞれ上図のような名前がついています．以降，<strong>ウィンドウ</strong>という用語は上図の該当部分の領域を指すために用いることとし，OS が各アプリケーションの表示に用いるウィンドウのことは指さないものとします．</p><p>また，各ウィンドウの下には，そのウィンドウに関する情報が付随しています．</p><figure class=""><label for="fig11835" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11835" class="margin-toggle"/><a href="../fig/03/buffer-info.png"><img src="../fig/03/buffer-info.png" alt=""/></a><span class="marginnote"></span></figure><p>さしあたり，「編集中マーク」「ファイル名」「カーソルの現在位置（この場合5行目の4文字目）」が分かれば十分です．</p><p>これまでにもいくつかの操作で使用していた画面下部の小さな領域を，Emacs では<strong>ミニバッファ</strong>と呼びます．操作に対する応答メッセージの表示や，ファイル名の指定のような単純なキーバインディングだけでは表現できない複雑な指示を与える場合の入力場所として用いられます．</p><p>さて，仮にコードが完成したとします．C-c C-k を押して実行してみましょう．</p><figure class=""><label for="fig11836" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11836" class="margin-toggle"/><a href="../fig/03/ex03-1-repl.png"><img src="../fig/03/ex03-1-repl.png" alt=""/></a><span class="marginnote"></span></figure><p>このように，一つのEmacsの画面中に複数のウィンドウが分割表示されることもあります．</p><p>ウィンドウに表示できるのはファイルの中身だけとは限りません．たとえば今回の場合，上半分はファイルの中身を表示していますが，下半分の Racket 対話環境には，ファイルの中身のような記録データではなく，Racket 処理系との標準入出力を介したやり取りが表示されています．このように「（横書きの）文字の列び」として表現できるデータ一般を表現するデータ構造<label for="side11837" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11837" class="margin-toggle"/><span class="sidenote">もう少し詳しく説明すると，横書きで列んでいる文字が順番に収められた文字配列，カーソルの現在位置を表す整数データ等々からなる複雑な構造体です．</span>のことを Emacs では<strong>バッファ</strong>と呼びます<label for="side11838" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11838" class="margin-toggle"/><span class="sidenote">ミニバッファは，1行だけのバッファなのでそう呼ばれています．</span>．バッファは Emacs プロセスが実行中に操作するデータ構造で，メモリ中に確保されています．</p><p>たとえばファイルを編集する場合，一文字入力する度にディスク上のファイルを読み書きしていたのでは動作が重たくなります．そこで，最初にファイルを開いた際にファイル中のデータ全体をメモリ上のバッファに一括して読み出しておき，普段の編集作業ではバッファに対する更新のみを行います．ファイルへの保存操作<label for="side11839" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11839" class="margin-toggle"/><span class="sidenote">キーバインディングは C-x C-s でしたね．</span>を行った時だけ，バッファ全体を一括してファイルに書き戻しています．ウィンドウ下部の編集中マーク（<code>**</code>）は，より正確には「バッファの内容と，それに対応するファイルの内容が異なっている」状態を表しているわけです．</p><p>また，Racket 対話環境の場合，Racket 処理系を実行している OS プロセスと Emacs を実行している OS プロセスが通信を行い，そのやり取りが順番にバッファ中に書き込まれているため，このように表示されています．このやり取りに対応するファイルはどこにも存在しないことに注意してください．</p><p>さて，テスト実行も無事に済み，課題2.1 を完成させたら次の課題に移りましょう．上半分に表示されている <code>ex03-1.rkt</code> 用ウィンドウにカーソルがある状態で，今度は <code>ex03-2.rkt</code> を開いてみてください．</p><figure class=""><label for="fig11840" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11840" class="margin-toggle"/><a href="../fig/03/ex03-2.png"><img src="../fig/03/ex03-2.png" alt=""/></a><span class="marginnote"></span></figure><p>のようになりますが，さっきまで見えていた <code>ex03-1.rkt</code> は一体どこへいったのでしょうか？</p><p>答えは（おそらく想像どおりでしょうが）「見えないけど存在はしている」です．今 Emacs がどのような状態になっているかを模式的に表すと下図のようになります<label for="side11841" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11841" class="margin-toggle"/><span class="sidenote">「Racket REPL」という名前のプロセスは，Racket の対話環境を動かしているプロセスです．Read-Eval-Print Loop（入力を読み込んで，それを評価し，結果を表示する，の繰り返し）の略です．</span>．</p><figure class="fullwidth"><label for="fig11842" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11842" class="margin-toggle"/><a href="../fig/03/model.png"><img src="../fig/03/model.png" alt=""/></a><span class="marginnote"></span></figure><p>左右の図は，それぞれ<code>ex03-2.rkt</code>を開く直前と直後の状態を表します．</p><p>ユーザからは，すべてのウィンドウが常に見えています．それぞれのウィンドウは Emacs 画面の一部を占めています．一方，ウィンドウとは独立に複数のバッファ（メモリ上のデータ構造）が存在しており，ウィンドウと紐付けられた一部のバッファの中身だけがユーザに見えています．</p><p>Emacs を使用中は常にどれか一つのウィンドウだけがアクティブな状態であり，ユーザからの操作のほとんどは，アクティブなウィンドウ<label for="side11843" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11843" class="margin-toggle"/><span class="sidenote">アクティブなウィンドウと紐付けられているバッファのことをアクティブなバッファと呼ぶことにします．</span>（あるいはアクティブなウィンドウに紐付けられたバッファ，さらにはそのバッファに紐付けられたプロセス）を対象に動作します．たとえば，カーソルの現在位置は各バッファのデータ構造中に存在する個別データですが，カーソル移動操作はその時にアクティブなバッファに対する操作（現在位置データの更新）となります．</p><p>このように，Emacs への様々な操作によってこの3層構造がどのように変化するかをイメージすると，各コマンドが正確に何をする操作なのかの理解が深まると思います．</p><p>それでは，この3層構造に関連したいくつかの操作を紹介しておきます．</p><ul><li><p><strong>C-x 1</strong></p><p>複数のウィンドウが分割表示されている場合，現在アクティブなウィンドウ1つだけを表示するようにします．</p></li><li><p><strong>C-x 2</strong></p><p>アクティブなバッファと紐付けられた新しいウィンドウを生成し，画面を上下に分割します．同じことを繰り返すとどんどん分割されていきますが，各ウィンドウが小さくなってくるので，2〜3個より多く分割するのはあまり実用的ではありません．</p><p>同様に，左右に分割する C-x 5 というコマンドもあります．一つのウィンドウに戻す操作は，どちらの分割であっても同じように機能します．</p></li><li><p><strong>C-x b</strong></p><p>上下にウィンドウを分割できるようになっても，両方で同じバッファを表示しつづけていたのではあまり意味がありません．C-x b を押すと，そのウィンドウで表示するバッファを変更することができます．ファイルを開く操作（C-x C-f）のように続けてバッファ名の入力<label for="side11844" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11844" class="margin-toggle"/><span class="sidenote">すでに気づいているかも知れませんが，C-x C-f や C-x b で入力する際，入力可能なファイル名やバッファ名の候補が画面上に一覧表示されます．一覧の表示中に C-n，C-p で候補を選択し Enter キーを押すことで入力することも可能です．名前の途中まで入力すると候補一覧が絞られたり，TAB キーで確定している（それ以外にはあり得ない）ところまでの文字列を補完入力してくれたりとかなり有能なので，色々試しながら操作に慣れておくと良いでしょう．</span>を求められます．ファイルが紐付けられたバッファの名前はファイル名と同じです．プロセスに紐付けられたバッファは，それぞれ特殊な名前が付いています．Racket の対話環境の場合，「<code>*Racket REPL*</code>」となっています．</p></li><li><p><strong>C-x o</strong></p><p>複数のウィンドウを分割表示していると，それらの間でカーソルを行ったり来たりさせたくなると思います．作業中のソースファイルと Racket 対話環境の間であれば，前回紹介した C-c C-z を押すことにより，互いの間でのカーソル移動が可能です．ただし，これは Racket モード特有のキーバインディングです．一般の Emacs バッファ間でカーソルを移動させたい場合<label for="side11845" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11845" class="margin-toggle"/><span class="sidenote">正確にはカーソルを移動させているのではなく「アクティブなウィンドウを切り替えている」だけなのですが，直感的にはバッファ間のカーソル移動のように捉えておけば十分です．その辺りは割といい加減に説明されていることも多く，ここでもあまり厳格な立場は取らず，イメージしやすい表現を適宜用いることにします．</span>には，C-x o を押します．押す度に，分割表示されているウィンドウを順番にカーソルが巡回していきます．</p></li><li><p><strong>C-x k</strong></p><p>C-x k については，前回，課題1.5に取り組む際の注意点として紹介しました．その時には，Racket 対話環境を終了させるための操作として紹介しましたが，より正確には「現在アクティブな（つまりカーソルのある）バッファを消去する」という操作になります．消去されたバッファを表示していたウィンドウには他のバッファが適当<label for="side11846" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11846" class="margin-toggle"/><span class="sidenote">大体の場合，直近に作業していたバッファ．</span>に選ばれて表示されます．</p><p>バッファを消去する際，紐付けられている実体がファイルかプロセスかによって挙動が異なります．</p><ul><li><p><strong>ファイルの場合</strong></p><p>バッファが編集中で，対応するファイルの内容と差がある場合：</p><pre><code>Buffer XXXX modified; kill anyway? (yes or no)</code></pre><p>とミニバッファに表示され（<code>XXXX</code> はバッファ名），それでもバッファを消去するかの確認を求められます．yes と答えるとバッファ中の修正内容は破棄されることになります．</p></li><li><p><strong>プロセスの場合</strong></p><p>対応するプロセスが実行中である場合：</p><pre><code>Buffer XXXX has a running process; kill it? (yes or no)</code></pre><p>とミニバッファに表示され（<code>XXXX</code> はバッファ名），プロセスの実行を終了（kill）させるか訊かれます．yes と答えるとバッファは消去され，プロセスは終了します．</p></li></ul></li><li><p><strong>C-x C-b</strong></p><p>これまでに紹介した一連のコマンドを使ってバッファをたくさんつくり始めると，そのうちに，使っていないバッファを見つけて消去するなど整理整頓したくなってきます．そのような目的のための「バッファを管理するためのバッファ」が存在します．適当なバッファ上で C-x C-b を押すと，現在 Emacs 中に存在する全てのバッファが一覧表示されている別のバッファが表れます．</p><p>このバッファの中では，C-f，C-b，C-n，C-p 等，通常の Emacs バッファと同じキーバインディングによる操作も行えますが，次に挙げる特別なキーバインディングによって操作するのが普通です．</p><ul><li>通常の C-n，C-p に加え，単に n，p キーを押すだけでも行を上下に移動できます．</li><li>Enter キーを押すとカーソルがある行のバッファを別のウィンドウで開きます（C-x b と同等の機能）．</li><li> d キーを押すことで，カーソルがある行のバッファに「削除マーク」を付けることができます．同じ操作を繰り返すことにより複数のバッファにマークをつけることもできます．また，間違ってマークを付けた場合には u キーで取り消せます．バッファにマークを付けた状態で x キーを押すと，それらのバッファを実際に消去します（C-x k と同等の機能）．</li><li>バッファを管理するためのバッファ自体は，C-x k 以外に q キーを押すことでも消去可能です．</li><li>他にもいくつか便利な操作が備わっています．? キーを押すと，より詳しい操作方法（ヘルプメッセージ）<label for="side11847" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11847" class="margin-toggle"/><span class="sidenote">英語です．特に情報科学の世界において，貴重な情報の多くは日本語ではなく英語で書かれています．がんばって英語も勉強しましょう．</span>の書かれたバッファが開きますので，そちらを参考にしてください．</li></ul></li></ul><p>最後に一つアドバイスです．Emacs を使い始めたばかりの初心者は，ファイルを一つ開く度に（シェルから <code>runemacs</code> を実行して）別々の Emacs プロセスを起動しがちです．しかし，たくさんの OS プロセスを立ち上げることは無駄な作業<label for="side11848" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11848" class="margin-toggle"/><span class="sidenote">余計な負荷をかけるため，PC 全体の性能にも悪影響です．また，Emacs プロセスの起動/終了に待たされる時間もけして短いとは言えずストレスフルです．</span>でしかありません．この節で紹介した操作を行えば，一つの Emacs プロセス内で複数のファイルを同時に編集できるので，ぜひ有効に使ってください．「演習が始まったら Emacs を1つだけ立ち上げ，終わるまではずっとその中で作業する」を基本スタイルにすると良いでしょう．</p><h3>コピー＆ペースト</h3><p>もちろん，Emacs の中でもいわゆる「切り取り」「コピー」「貼り付け」といった編集作業が可能です．関連する操作を順に見ていきましょう．</p><ul><p><anchor id="region"></anchor></p><li><p><strong>C-SPC</strong></p><p>他の多くのアプリケーションでは，マウスのドラッグ操作を使って範囲選択してから切り取りやコピー操作を行うと思いますが，Emacs では範囲選択もマウスではなくキーボードを使って行います．C-SPC（SPC はスペースキーのこと）を押すと，カーソルの現在位置を範囲選択の開始位置として<strong>マーク</strong>します．マウスのドラッグ操作における最初の左ボタンを押さえる操作に相当します．</p><p>C-SPC を一度押してから，適当にカーソルを移動させてみてください．マークした位置からカーソル位置までのテキストの色が反転されると思います．反転している領域が切り取りやコピーの操作対象となります．</p></li><li><p><strong>C-w</strong></p><p>上記の操作により選択した範囲を切り取ります．切り取ったテキストは，<strong>キルリング</strong><label for="side11849" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11849" class="margin-toggle"/><span class="sidenote">Windows 等で一般にクリップボードと呼ばれるものに相当．</span>と呼ばれるメモリ上の領域に一時保存されています．</p></li><li><p><strong>M-w</strong></p><p>C-w と操作方法は同じですが，こちらは「切り取り」ではなく「コピー」を行います．</p></li><li><p><strong>C-y</strong></p><p>キルリングに一時保存されているテキストをカーソルのある位置に貼り付けます．</p></li></ul><p>文字による説明だけだと少し分かりにくいかも知れませんので，いくつかの簡単な操作例を動画で載せておきます．</p><ol><li><p>短いテキストのコピー</p><p>C-SPC，M-w，C-y の3つの操作を行っています．</p><figure class="fullwidth"><label for="fig11850" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11850" class="margin-toggle"/><a href="../fig/03/copy-word.gif"><img src="../fig/03/copy-word.gif" alt=""/></a><span class="marginnote"></span></figure></li><li><p>複数行にまたがるテキストのコピー</p><p>C-SPC，M-w，C-y の3つの操作を行っています．</p><figure class="fullwidth"><label for="fig11851" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11851" class="margin-toggle"/><a href="../fig/03/copy-lines.gif"><img src="../fig/03/copy-lines.gif" alt=""/></a><span class="marginnote"></span></figure></li></ol><p>上記の4つの操作の組み合わせで任意の範囲のテキストの切り取り，コピー，貼り付けが可能です．</p><p>選択範囲を対象とする代わりに，行単位で同様の作業を行う方法として，C-k があります．C-k を押すことにより，<strong>カーソル位置からその行の末尾まで</strong>の範囲のテキストを切り取ることが可能です．ただし末尾の改行文字は含まれません．改行を含めて削除したい場合には C-k を連続して2回押しましょう．そうすると，改行文字と合わせた1行がキルリングに一時保存されます．</p><p>典型的には，先述した C-a によりカーソルを行の先頭に移動させてから C-k を2回連続で押すことによって行全体を切り取る操作を頻繁に行います．切り取った1行を別の場所に貼り付けるには，通常と同じ C-y を使います．</p><p>さらに，「C-k を2回連続で押す」を連続で何度も行うことにより，複数行をまとめてキルリングに一時保存することも可能です．これも簡単な操作例を動画で載せておきます．この例では，C-a を1回，C-k を連続して8回，C-y を1回（消した行を元に戻す），（カーソル移動の後）C-y を1回押しています．</p><p> </p><figure class=""><label for="fig11852" class="margin-toggle">&amp;#8853;</label><input type="checkbox" id="fig11852" class="margin-toggle"/><a href="../fig/03/kill-lines.gif"><img src="../fig/03/kill-lines.gif" alt=""/></a><span class="marginnote"></span></figure><p>このように，連続する複数行をまとめて削除したり移動したりといった操作は頻繁に行いますから，C-w，M-w と C-k の両方を適宜使い分けながら併用するのがおすすめです．</p><p>最後に，切り取り操作などを行っていると，ときどき誤って本当は消したくなかったテキストを消してしまうことがあります．そのような場合には，C-x u 操作により直前に実行した操作を取り消す（undo）ことが可能です．C-x u を連続して行うことで複数回の直近の操作を取り消すことも可能です．</p><p><anchor id="init-el"></anchor></p><h3><code>init.el</code>ファイルについて</h3><p>みなさんが使っている Emacs の環境は，<a href="01_basic.html#init-el" class="internal">前回の設定ファイルの設置</a>によってカスタマイズされています．ユーザ一人一人の好みに合わせて設定を書き換えることで，いくらでも便利になっていきます．ネットで調べれば，設定ファイルにどのように記述すると望んでいる機能が有効になるのかの情報が得られます．しかし，設定を非常に柔軟に行えることと引き換えに，一般の GUI アプリケーションと比べとくに初心者には設定の書き方が難しいことも事実です．<label for="side11853" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11853" class="margin-toggle"/><span class="sidenote">設定ファイルは Emacs Lisp と呼ばれる Lisp の方言で書かれています．みなさんが学んでいる Scheme も Lisp の方言なので親戚みたいなものです．ですので，この演習でしっかりと Scheme を学べば何となく Emacs Lisp も理解できるようになってきます（私の感覚だと，標準語と関西弁程度の少し(？)の違いしかありません）．</span></p><p>ここでは，配布している <code>init.el</code> 中の設定のうち，簡単に書き換えられる項目を2つほど紹介しておきます．それぞれファイルの何行目に書かれているかも示しています．ファイルを開いたら，先に述べた C-x C-g による該当行への移動操作を使ってジャンプしましょう．</p><ol><li><p>フォントの指定（61行目）</p><div class="highlight"><pre><code>;; フォント
(set-frame-font (cond ((eq window-system 'w32) "Consolas-13")
                      ((eq window-system 'x) "Ricty Diminished-18")
                      (t "Monaco-13")))</code></pre></div><p>強調されている行にある文字列 <code>"Consolas-13"</code> がフォントの名前とサイズを意味しています．画面の大きさや解像度に合わせて好みのサイズに書き換えると良いでしょう．Emacs を再起動するとフォントが変わります．なお，Linux の場合の設定が次の行，Windows でも Linux でもない場合の設定がさらにその次の行に書かれています．場合分けを意味する <code>cond</code> 式は（<code>else</code> が <code>t</code> と書かれていることを除き）Scheme とまったく一緒です．</p><p>なお，フォントの種類を他のものに変更する場合，等幅フォント<label for="side11854" class="margin-toggle sidenote-number"></label><input type="checkbox" id="side11854" class="margin-toggle"/><span class="sidenote">自分の PC にどんな等幅フォントが入っているかの調べ方はググるなどして調べてください．</span>にすることを強くお勧めします．プログラムコードを可変幅フォントで表示すると非常に見にくくなります．</p></li><li><p>行番号の表示（77行目）</p><div class="highlight"><pre><code>;; 行番号を各行に表示
;;(global-linum-mode t)</code></pre></div><p>強調されている行のコメントを外すことで，バッファの各行の左端に行番号が表示されるようになります．</p></li></ol><p>その他の設定項目についてもファイル中に簡単なコメントをつけてありますので，それを読んで興味のある人は色々と書き換えて試してみても良いでしょう．中には，Emacs がそれまでのように上手く起動しなくなることもありますが，その場合は設定を元に戻す（最悪の場合でも前回の資料の中から元の <code>init.el</code> を再度ダウンロードして上書きする）だけで済みますので，躊躇する必要はありません．</p></section><p><anchor id="exercise"></anchor></p><section><h2>今週の課題</h2><p>全部で9問あります．今回は，<strong>解いた課題の★の数の合計が5個以上</strong>であることを最低条件とします．もちろん，それに縛られず一つでも多くの課題にチャレンジしてください．</p><ul><li>解いた課題の★の数の合計：5個以上</li><li>提出期限：4/27(水) 19:00</li><li>zip に圧縮するディレクトリ名：<tt>ex03</tt></li><li>提出する zip ファイル名：<tt>ex03.zip</tt></li></ul><div class="exercise"><h4>課題3.1 [★] [<a href="../pdf/jsicp.pdf#page=71" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.11を解きなさい．配布ファイル <code>ex03/ex03-1.rkt</code> に解答コードを書き加えて完成させること．</p><p>再帰的プロセスの方法で <code>f</code> を計算する手続きの名前を <code>f-rec</code>，反復的プロセスの方法で <code>f</code> を計算する手続きの名前を <code>f-iter</code> とすること．</p><blockquote>ヒント： <code>f-iter</code> は引数が一つだけであるが，「状態」を覚えておくため，追加の引数を受け取る別の補助手続きを用いると良い．(補助手続きは，<code>f-iter</code> の内部手続き定義として定義するのが美しいやり方だが，必ずしもそうする必要はない．)</blockquote></p></div><div class="exercise"><h4>課題3.2 [★] [<a href="../pdf/jsicp.pdf#page=72" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.12を解きなさい．配布ファイル <code>ex03/ex03-2.rkt</code> に解答コードを書き加えて完成させること．</p><p>定義する手続きの名前を <code>pascal</code> とする．<code>pascal</code> はパスカル三角形中の位置を表す二つの自然数 i, j を引数に受け取り，対応する要素を返すこと．i, j は，下図のとおり上からi 番目，その列の左端から j 番目の位置（ただし，0 から数える）を表すものとする．</p><pre><code>i = 0:      1
i = 1:     1 1
i = 2;    1 2 1
i = 3:   1 3 3 1
i = 4:  1 4 6 4 1
------------------
  j =   0 1 2 3 4 (i = 4 の行の場合)</code></pre></p></div><div class="exercise"><h4>課題3.3 [★★★] [<a href="../pdf/jsicp.pdf#page=76" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.16を解きなさい．配布ファイル <code>ex03/ex03-3.rkt</code> に解答コードを書き加えて完成させること．</p><p>定義する手続きは <code>(fast-expt-iter b n)</code> とする．<code>fast-expt-iter</code> は <code>b</code> の <code>n</code> 乗を計算する．</p></p></div><div class="exercise"><h4>課題3.4 [★★] [<a href="../pdf/jsicp.pdf#page=76" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.17を解きなさい．配布ファイル <code>ex03/ex03-4.rkt</code> に解答コードを書き加えて完成させること．</p><p>定義する手続きは <code>(fast-* a b)</code> とする．<code>fast-*</code> は <code>a</code> 掛ける <code>b</code> を計算する．</p><blockquote>注：この問題の解答は再帰プロセスで良い（反復的プロセスの定義はこの次の課題）．</blockquote></p></div><div class="exercise"><h4>課題3.5 [★★★] [<a href="../pdf/jsicp.pdf#page=77" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.18を解きなさい．配布ファイル <code>ex03/ex03-5.rkt</code> に解答コードを書き加えて完成させること．</p><p>定義する手続きは <code>(fast-*-iter a b)</code> とする．<code>fast-*-iter</code> は <code>a</code> 掛ける <code>b</code> を反復的プロセスによって計算する．</p><p>課題3.3が解けたなら，この課題も簡単に解ける．</p></p></div><div class="exercise"><h4>課題3.6 [★★] [<a href="../pdf/jsicp.pdf#page=77" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.19を解きなさい．配布ファイル <code>ex03/ex03-6.rkt</code> に解答コードを書き加えて完成させること．</p><p>ファイル中の定義の未完成部分 <code>(???)</code> を正しい式に置き換えなさい．それ以外の箇所を書き換えてはいけません．</p><blockquote>ヒント： 一見すると問題文中の説明は複雑そうですが，よく読めばそれほど難しいことは言ってません．</blockquote></p></div><div class="exercise"><h4>課題3.7 [★] [<a href="../pdf/jsicp.pdf#page=85" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.22を解きなさい．配布ファイル <code>ex03/ex03-7.rkt</code> に解答コードを書き加えて完成させること．</p><p>手続き <code>(search-for-primes low high)</code> を定義しなさい．<code>low</code> から <code>high</code> の範囲の奇数に対し，順に <code>timed-prime-test</code> を呼び出し，素数である場合にだけ以下のような表示を行う手続きである．</p><pre><code>ex03-7.rkt&gt; (search-for-primes 1000000000000 1000000000100)
1000000000039 *** 37
1000000000061 *** 35
1000000000063 *** 32
1000000000091 *** 32
#t</code></pre><p>たとえば，上の実行結果では，素数 1000000000039 の判定に 37ms の時間がかかっていることを示している．</p><p>定義し終えたら，手続き <code>test</code> を実行し，テキスト問題文に書かれているような実行時間の増加傾向が見られるか確認せよ．（テキストが書かれた当時とは PC の計算能力が段違いなため，かなり大きな数まで試すように書かれている．）</p></p></div><div class="exercise"><h4>課題3.8 [★★] [<a href="../pdf/jsicp.pdf#page=87" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.27を解きなさい．配布ファイル <code>ex03/ex03-8.rkt</code> に解答コードを書き加えて完成させること．</p><p>問題文に従い，手続き <code>(carmichael-test n)</code> を定義しなさい．</p></p></div><div class="exercise"><h4>課題3.9 [★★★] [<a href="../pdf/jsicp.pdf#page=87" class="external">テキスト中の問題文へのリンク</a>]</h4><p><p>リンク先の問題1.28を解きなさい．配布ファイル <code>ex03/ex03-9.rkt</code> に解答コードを書き加えて完成させること．</p><p>問題文に従い，手続き <code>(expmod base exp n)</code> ならびに<code>(miller-rabin-test n)</code> を定義しなさい．</p><p>正しく解けていれば，<code>test</code> を呼び出して <code>FAILURE</code> が一つも発生しない．</p></p></div></section><p><anchor id="literacy-table"></anchor></p><section><h2>リテラシ関連項目まとめ</h2><p>利便性のため，前回までの操作方法・コマンドも全て含んでいます．今回追加された項目は<strong>太字</strong>で表しています．</p><h3>Emacs</h3><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-f</code></td><td>カーソルを右（forward）へ1文字分だけ移動</td></tr><tr><td><code>C-b</code></td><td>カーソルを左（backward）へ1文字分だけ移動</td></tr><tr><td><code>C-n</code></td><td>カーソルを下（next）へ1行分だけ移動</td></tr><tr><td><code>C-p</code></td><td>カーソルを上（previous）へ1行分だけ移動</td></tr><tr><td><strong><code>C-v</code></strong></td><td><strong>カーソルを下へ1画面分だけ移動</strong></td></tr><tr><td><strong><code>M-v</code></strong></td><td><strong>カーソルを上へ1画面分だけ移動</strong></td></tr><tr><td><strong><code>M-&lt;</code></strong></td><td><strong>カーソルをバッファの先頭へ移動</strong></td></tr><tr><td><strong><code>M-&gt;</code></strong></td><td><strong>カーソルをバッファの末尾へ移動</strong></td></tr><tr><td><strong><code>C-a</code></strong></td><td><strong>カーソルを現在行の先頭へ移動</strong></td></tr><tr><td><strong><code>C-e</code></strong></td><td><strong>カーソルを現在行の末尾へ移動</strong></td></tr><tr><td><strong><code>C-x C-g</code></strong></td><td><strong>カーソルを指定行へ移動</strong></td></tr><tr><td><strong><code>C-l</code></strong></td><td><strong>カーソルのある行が画面の中央になるよう再描画</strong></td></tr><tr><td><code>C-d</code></td><td>カーソル上の1文字を削除</td></tr><tr><td><code>C-h</code></td><td>カーソル直前の1文字を削除</td></tr><tr><td><strong><code>C-SPC</code></strong></td><td><strong>カーソル位置にマークを設定</strong></td></tr><tr><td><strong><code>C-w</code></strong></td><td><strong>選択範囲を切り取り</strong></td></tr><tr><td><strong><code>M-w</code></strong></td><td><strong>選択範囲をコピー</strong></td></tr><tr><td><strong><code>C-y</code></strong></td><td><strong>キルリングの内容を貼り付け</strong></td></tr><tr><td><strong><code>C-k</code></strong></td><td><strong>行末尾までの切り取り</strong></td></tr><tr><td><code>C-x C-f</code></td><td>ファイルを開く</td></tr><tr><td><code>C-x C-s</code></td><td>ファイルの保存</td></tr><tr><td><code>C-x C-c</code></td><td>Emacs を終了</td></tr><tr><td><strong><code>C-x b</code></strong></td><td><strong>表示するバッファを変更</strong></td></tr><tr><td><strong><code>C-x C-b</code></strong></td><td><strong>バッファ管理用バッファを表示</strong></td></tr><tr><td><code>C-x k</code></td><td>バッファを閉じる</td></tr><tr><td><code>C-g</code></td><td>コマンドの中断</td></tr><tr><td><strong><code>C-x 2</code></strong></td><td><strong>ウィンドウを上下に分割</strong></td></tr><tr><td><strong><code>C-x 5</code></strong></td><td><strong>ウィンドウを左右に分割</strong></td></tr><tr><td><strong><code>C-x 1</code></strong></td><td><strong>ウィンドウを1つにする</strong></td></tr><tr><td><strong><code>C-x o</code></strong></td><td><strong>アクティブなウィンドウの切り替え</strong></td></tr></table><h3>Racketモード</h3><table><tr><th>キー</th><th>意味</th></tr><tr><td><code>C-c C-k</code></td><td>ソースファイルを対話環境に読み込む</td></tr><tr><td><code>C-c C-z</code></td><td>ソースファイルと対話環境の間のカーソル移動</td></tr></table><h3>シェル</h3><table><tr><th width="180px">コマンド</th><th>意味</th></tr><tr><td><code>pwd</code></td><td>カレントディレクトリを表示（present working directory）</td></tr><tr><td><code>cd </code><i>dir</i></td><td>カレントディレクトリを <i>dir</i> へ変更．<i>dir</i> を指定しない場合はホームディレクトリへ変更（change directory）</td></tr><tr><td><code>ls </code><i>dir</i></td><td>ディレクトリ <i>dir</i> の中身（<i>dir</i> を省略した場合はカレントディレクトリの中身）をリスト表示（list）</td></tr><tr><td><code>cp </code><i>src</i><code> </code><i>dst</i></td><td>ファイル <i>src</i> を <i>dst</i> へコピー（copy）</td></tr><tr><td><code>mv </code><i>src</i><code> </code><i>dst</i></td><td>ファイル <i>src</i> を <i>dst</i> へ移動（move）</td></tr><tr><td><code>rm </code><i>file</i> ...</td><td><i>file</i> ... を削除（remove）</td></tr><tr><td><code>echo </code><i>msg</i></td><td>文字列 <i>msg</i> を標準出力に表示</td></tr><tr><td><code>mkdir </code><i>dir</i></td><td>ディレクトリ <i>dir</i> を作成（make directory）</td></tr><tr><td><code>unzip </code><i>file</i></td><td>zip ファイル <i>file</i> をカレントディレクトリに展開</td></tr><tr><td><code>zip -r </code><i>file</i><code> </code><i>dir</i></td><td>ディレクトリ <i>dir</i> を zip ファイル <i>file</i> に圧縮</td></tr></table></section>
    </article>
    <nav class="bottom">
      <ul>
        <li>&nbsp;</li>
        <li>
        <a href="../chap/02_basic.html">&larr; Previous</a>

        </li>
        <li><a href="../index.html"><i class="fas fa-home"></i> Home</a></li>
        <li><a href="../chap/04_hof.html">Next &rarr;</i></a></li>
        <li class="right copy">&copy; 2022 Seiji Umatani</li>
      </ul>
    </nav>
  </body>
</html>